---
layout: post
title: ¿Te preocupas por tu código? Haz (¡ya!) un seguimiento de la cobertura de código
  en el código nuevo
date: '2015-06-05T10:06:00.000+02:00'
author: Unknown
categories:
- testing
- sonarqube
- calidad
modified_time: '2015-06-05T12:08:08.554+02:00'
blogger_id: tag:blogger.com,1999:blog-6299073294914176200.post-1266261602582209744
redirect_from: /2015/06/te-preocupas-por-tu-codigo-haz-ya-un.html
---

<span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;">Traducción del artículo escrito por <a href="https://www.linkedin.com/profile/view?id=935307&amp;authType=NAME_SEARCH&amp;authToken=edPa&amp;locale=es_ES&amp;trk=tyah&amp;trkInfo=clickedVertical%3Amynetwork%2Cidx%3A1-1-1%2CtarId%3A1433490490695%2Ctas%3AFreddy%20Mallet" target="_blank">Freddy Mallet</a>, director de producto de <a href="http://www.sonarsource.com/" target="_blank">Sonar Source</a>. <a href="http://www.sonarqube.org/do-you-care-about-your-code-track-code-coverage-on-new-code-right-now/" target="_blank">Ver el artículo original</a>&nbsp;</span><br /><div><span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">___________________________________________________________________________________________________</span><br /><div><br /><div style="text-align: justify;"><span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;">Hace algún tiempo, tuve un debate apasionado con un viejo amigo y compañero de profesión Nicolas Frankel sobre la utilidad de la métrica de cobertura de código. Lo empezamos en Twitter y luego él escribió una entrada de blog en la que afirmaba que la métrica de cobertura de código era inútil e insignificante. No es sólo que yo piense completamente lo contrario, sino que me atrevería a decir que hoy en día es casi una locura el no hacer un seguimiento de la cobertura en el nuevo código.</span></div><span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;"> </span><br /><div style="text-align: justify;"><span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;"><br /></span></div><span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;"></span><div style="text-align: justify;"><span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;"><b><span style="color: orange;">Por lo que yo sé, no he encontrado nada en el código&nbsp;</span></b></span></div><span style="font-family: Catamaran, Helvetica Neue, Arial, Helvetica, sans-serif;"><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Pero antes de hablar de la importancia de hacer un seguimiento de la cobertura de código en el nuevo código y el cambio de paradigma, empecemos por mencionar algo que es probablemente una de las causas fundamentales del desacuerdo con Nicolas: las herramientas de análisis estático y dinámico nunca, jamás, lograrán decir "su código está limpio, bien diseñado, libre de errores y con un alto grado de mantenimiento". Las herramientas de un análisis estático y dinámico sólo son capaces de decir "Por lo que sé, no he encontrado nada malo en el código.". De este modo, esto también se extiende para cualquier métrica o técnica utilizada para entender y analizar el código fuente. Un alto nivel de cobertura no es una garantía de calidad del producto, pero un bajo nivel sí es una clara indicación de testeo insuficiente.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Para Nicolas, el seguimiento de la cobertura de código es inútil porque en algunos casos, las pruebas unitarias que conducen a aumentar la cobertura de código pueden ser muy cutres. Por ejemplo, las pruebas unitarias no pueden contener aserciones, o pueden cubrir todas las ramas pero no todos los parámetros de entrada posibles. Para solucionar estas limitaciones, Nicolas dice que la única solución es hacer algunas pruebas de mutación mientras se mide la cobertura de código (véase, por ejemplo, <a href="http://pitest.org/">pitest.org</a> para Java) y así garanitzar que las pruebas unitarias son sólidas. Ok, pero si realmente quieres tocar el Grial, ¿esto es suficiente? ¡Para nada! Puedes tener un 100% de cobertura de código y algunas muy sólidas pero… pueden ser pruebas unitarias totalmente imposibles de mantener. Las pruebas de mutación no proporcionan, de ninguna manera, el saber cómo de “unitarias” son tus pruebas unitarias, o si hay mucha redundancia entre ellas.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Resumiendo, cuando te preocupas por la capacidad de mantenimiento, fiabilidad y seguridad de tu aplicación, se puede y debe invertir tiempo y esfuerzo para llegar a algunos niveles de madurez más altos. Pero si esperas hasta encontrar la solución definitiva para empezar, nunca sucederá. Además, los niveles de madurez deberían alcanzarse progresivamente:&nbsp;</div><div style="text-align: justify;"><ul><li>No tiene mucho sentido preocuparse por la cobertura de código si no hay un contexto de integración continua.&nbsp;</li><li>No tiene mucho sentido preocuparse por las pruebas de mutación si sólo el 5% del código fuente está cubierto por pruebas unitarias.&nbsp;</li><li>Etc.&nbsp;</li></ul></div><div style="text-align: justify;">Y aquí ni siquiera menciono el esfuerzo extra que conlleva la ejecución de las pruebas de mutación y el análisis de los resultados. Pero no nos vayamos por las ramas: la mutación es una gran técnica y os animo a que lo probéis en: http://pitest.org/ y el <a href="http://docs.sonarqube.org/display/SONAR/Documentation" target="_blank">SonarQube Pitest Plugin</a>, creado por <a href="https://twitter.com/alex_victoor" target="_blank">Alexandre Victoor</a>. Simplemente digo que, como punto de partida, las pruebas de mutación son ya una técnica demasiado avanzada.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><span style="color: orange;">Los desarrolladores quieren aprender&nbsp;</span></b></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Hay un segundo punto de desacuerdo con Nicolas: ¿deberíamos confiar en que los desarrolladores quieren progresar? Si la respuesta es que NO, puede que pasemos toda una vida luchando con ellos y siempre haciendo su vida más difícil. Obviamente, siempre encontrarás algunos desarrolladores reacios, retrasando el trabajo y que no se preocupan en absoluto por la calidad y la fiabilidad del código fuente. Pero prefiero dirigirme a la gran mayoría de los desarrolladores deseosos de aprender y progresar. Para esa gran mayoría de los desarrolladores, el objetivo es siempre hacer la vida más divertida en lugar de hacer que sea más difícil. Así que, ¿cómo contagias a esos desarrolladores con ganas de aprender el deseo de hacer pruebas unitarias?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Al iniciar el desarrollo de una aplicación de pruebas de unidad desde cero puede ser bastante fácil. Pero cuando mantienes una aplicación con 100.000 líneas de código y sólo el 5% está cubierto por las pruebas unitarias, puede que te deprimas rápidamente. Y, obviamente, la mayoría de nosotros estamos tratando con código heredado. Cuando estás empezando tan atrás, puede requerir años el llegar a una cobertura total de pruebas unitarias del 90%. Así que para esos primeros años, ¿cómo vas a reforzar la práctica? ¿Cómo te vas a asegurar que en un equipo de 15 desarrolladores todos ellos juegan el mismo juego?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><span style="color: orange;">Hemos suspendido durante muchos años&nbsp;</span></b></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">En efecto, estuvimos bloqueados con una cobertura de código del 60% de la plataforma y no fuimos capaces de progresar. Por suerte, <a href="https://twitter.com/dgageot" target="_blank">David Gageot</a> se incorporó al equipo por aquél entonces y las cosas fueron bastante sencillas para él: cualquier nueva pieza de código debería tener una cobertura de al menos un 100% :) Así fue y eso es lo que hizo. Desde entonces decidimos establecer un umbral de calidad con un simple pero efectivo criterio: cuando liberamos una nueva versión de cualquier producto, la cobertura de ese código nuevo o actualizado no puede ser menos de un 80%. Sí lo es, entonces la petición de liberación de versión se rechaza. Así fue, eso es lo que hicimos, y empezamos finalmente a volar. Un año y medio después, la cobertura de código de la plataforma SonarQube es 82 – 84% en el conjunto de productos de SonarSource (400.000 líneas de código y 20.000 pruebas unitarias).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><span style="color: orange;">La cobertura en código nuevo/modificado cambia las reglas del juego&nbsp;</span></b></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Y es bastante sencillo entender por qué:&nbsp;</div><div style="text-align: justify;"><ul><li>Sea cual sea tu aplicación, e independientemente de si es heredada o no, el umbral de calidad es siempre el mismo y no evoluciona con el tiempo: sólo haz la cobertura en tus nuevas o cambiadas líneas de código mayores que X%.&nbsp;</li><li>Ya no hay necesidad de mirar la cobertura de código global o la Deuda Técnica heredada. ¡Olvídalo y deja de deprimirte!&nbsp;</li><li>Como cada año el X% de tu cobertura de código total evoluciona (en Google, por ejemplo, supone el 50%), tener cobertura en código modificado significa que, incluso sin prestar atención a la cobertura total, ésta crecerá muy rápido simplemente como un “efecto secundario”.&nbsp;</li><li>Si una parte de la aplicación no está cubierta en absoluto por las pruebas unitarias, pero no ha evolucionado durante los últimos 3 años, ¿por qué debería invertir esfuerzo en aumentar la capacidad de mantenimiento de esa parte del código? No tiene sentido. Con este enfoque, podrás empezar a cuidar de ese código si, y sólo si, un día se tienen que hacer algunos cambios funcionales. En otras palabras, el coste para arrancar este proceso es pequeño. No hay necesidad de parar un proyecto y hacer a todo el equipo trabajar X meses sólo para reembolsar la deuda técnica heredada.&nbsp;</li><li>Los nuevos desarrolladores no tienen otra opción que jugar al juego desde el primer día, porque si comienzan a incluir piezas de código no cubiertas, el feedback llega en cuestión de horas, y en cualquier caso ese nuevo código nunca entrará en producción.&nbsp;</li></ul></div><div style="text-align: justify;">Este nuevo enfoque para hacer frente a la Deuda Técnica es parte de este cambio de paradigma y que se explica en nuestro libro blanco "Continuous Inspection". En otra entrada de blog seguiremos explicando cómo hacer fácilmente un seguimiento de cualquier tipo de deuda técnica con este enfoque, no sólo de la deuda relacionada con la falta de cobertura de código. Y gracias Nicolas Frankel por seguir alimentando este debate abierto.</div></span></div></div>